import { TransferEvent, Balances, Accounts, Snapshot } from "./types"
import { AxiosResponse } from "axios"

import { formatFixed } from "@ethersproject/bignumber";
import { utils, BigNumber } from "ethers"
import axios from "axios"
import fs from "fs"

import * as dotenv from "dotenv"

import {
  EVENT_ERC20_TRANSFER,
  EVENT_ERC20_TRANSFER_COUNT
} from "./constants/queries"
import {
  BITQUERY_ENDPOINT,
  EXPLOITED_ASSETS,
  LP_ADDRESSES,
  EXPLOIT_BLOCK,
  DEPLOYMENT_BLOCKS,
  BMAP,
  BMAP_SNAPSHOT,
  ZERO_ADDRESS,
  TOKEN_SYMBOLS,
  BN_ZERO
} from "./constants"


dotenv.config()

const headers = {
  "Content-Type": "application/json",
  "X-API-KEY":  `${process.env.BITQUERY_APIKEY}`
}

const baseDenom = BigNumber.from(10).pow(18)

function toBN(amount: string): BigNumber {
  return BigNumber.from(amount)
}

function fromBN(amount: BigNumber): string {
  return formatFixed(amount, 18)
}

async function makeRequest(endpoint: string, request: string)
  : Promise<AxiosResponse<any, any>> {
  return await axios({
    method: "post", url: endpoint,
    data: {
      query: request
    },
    headers
  })
}

function getSnapshotAt(
  network: string,
  tokenAddress: string,
  startBlock: number,
  endBlock: number,
  offset: number
) : Promise<TransferEvent[]> {
  return new Promise((resolve) => {
    makeRequest(
      BITQUERY_ENDPOINT,
      EVENT_ERC20_TRANSFER(
        network,
        tokenAddress,
        startBlock,
        endBlock,
        offset
      )
    )
    .then(response => response.data.data.ethereum)
    .then(e => resolve(e.smartContractEvents))
  })
}

function getEventCount(
  network: string,
  tokenAddress: string,
  startBlock: number,
  endBlock: number
) : Promise<number> {
  return new Promise((resolve) => {
    makeRequest(
      BITQUERY_ENDPOINT,
      EVENT_ERC20_TRANSFER_COUNT(
        network,
        tokenAddress,
        startBlock,
        endBlock
      )
    )
    .then(response => response.data.data.ethereum)
    .then(e => resolve(e.smartContractEvents[0].count))
  })
}

function computeOutstandingBalances(
  events: TransferEvent[],
  balances: Accounts,
  network: string,
  tokenAddress: string,
  lpAddresses: string[]
) : Promise<Accounts> {
  return new Promise((resolve) => {
    const token = TOKEN_SYMBOLS[tokenAddress]

    for(let x = 0; x < events.length; x++) {
      const block = events[x].arguments

      for(let y = 0; y < block.length; y++) {
        const [ sender, receiver, amount ] = block.slice(y, y + 3)

        const receiverAddress = receiver.value.toLowerCase()
        const senderAddress = sender.value.toLowerCase()
        const transferAmount = toBN(amount.value)

        if(!balances[receiverAddress]) {
          balances[receiverAddress] = BMAP
        }
        if(!balances[senderAddress]) {
          balances[senderAddress] = BMAP
        }

        const prevSenderBalance = balances[senderAddress][network][token]
        const prevReceiverBalance = balances[receiverAddress][network][token]

        const newReceiverBalance = transferAmount.add(prevReceiverBalance)
        const newSenderBalance = prevSenderBalance.sub(transferAmount)

        if(senderAddress !== ZERO_ADDRESS) {
          balances[senderAddress] = {
            ...balances[senderAddress],
            [network]: {
              ...balances[senderAddress][network],
              [token]: newSenderBalance
            }
          }
        }
        if(receiverAddress !== ZERO_ADDRESS) {
          balances[receiverAddress] = {
            ...balances[receiverAddress],
            [network]: {
              ...balances[receiverAddress][network],
              [token]: newReceiverBalance
            }
          }
        }
        y = y + 2
      }
    }
    resolve(balances)
  })
}

async function takeSnapshot(
  network: string,
  tokenAddress: string,
  startBlock: number,
  endBlock: number
) : Promise<TransferEvent[]> {
  let events: TransferEvent[] = []

  const chunkSize = 25000
  const eventCount = await getEventCount(
    network, tokenAddress, startBlock, endBlock
  )

  const chunkCount = Math.ceil(eventCount / chunkSize)

  for( let x = 0; x < chunkCount; x++) {
    const batchEvents = await getSnapshotAt(
      network,
      tokenAddress,
      startBlock,
      endBlock,
      events.length
    )

    events = events.concat(batchEvents)
  }

  return events
}

async function snapshotTokens(
  network: string,
  tokenAddresses: string[],
  lpAddresses: string[],
  startBlockRange: number[],
  endBlockRange: number[]
) : Promise<Accounts> {
  let mapping: Accounts = {}

  const events = await Promise.all(
    tokenAddresses.map((e: string, i: number) =>
      takeSnapshot(
        network,
        e,
        startBlockRange[i],
        endBlockRange[i]
      )
    )
  )

  for (let i in events) {
    mapping = await computeOutstandingBalances(
      events[i],
      mapping,
      network,
      tokenAddresses[i],
      lpAddresses
    )
  }

  return mapping
}

async function formatForFile(snapshot: Accounts, networks: string[])
: Promise<Snapshot>
{
  return new Promise((resolve) => {
    const networkSnapshots: Snapshot = {}
    const keyEntries = Object.entries(snapshot)

    for(let i in keyEntries) {
      const [ address, netIdAccounts ] = keyEntries[i]
      const keyValues = Object.entries(netIdAccounts)

      // let balanceSum = BN_ZERO

      if(!networkSnapshots[address]) {
        networkSnapshots[address] = BMAP_SNAPSHOT
      }

      for(let x in keyValues) {
        const [ netId, balances ] = keyValues[x]
        const balanceMapping = Object.entries(balances)

        for(let z in balanceMapping) {
          const [ token, balance ] = balanceMapping[z]

          // balanceSum = balanceSum.add(balance)

          networkSnapshots[address] = {
            ...networkSnapshots[address],
            [netId]: {
              ...networkSnapshots[address][netId],
              [token]: fromBN(balance)
            }
          }
        }
      }
      // if(balanceSum.eq(BN_ZERO)) {
      //  delete networkSnapshots[address]
      // }
    }
    resolve(networkSnapshots)
  })
}

async function exploitSnapshot()
{
  const snapshot = await snapshotTokens(
    "ethereum",
    EXPLOITED_ASSETS.ethereum,
    LP_ADDRESSES.ethereum,
    DEPLOYMENT_BLOCKS.ethereum,
    new Array(3).fill(EXPLOIT_BLOCK.ethereum)
  )

  // snapshot = await snapshotTokens(
  //  "matic",
  //  EXPLOITED_ASSETS.matic,
  //  LP_ADDRESSES.matic,
  //  DEPLOYMENT_BLOCKS.matic,
  //  new Array(3).fill(EXPLOIT_BLOCK.matic),
  //  snapshot
  // )

  fs.writeFileSync("snapshot.json",
    JSON.stringify(await formatForFile(
      snapshot, [ "ethereum" ]
    ))
  )

  console.log('Snapshot done')
}

exploitSnapshot()
